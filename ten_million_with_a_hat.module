<?php

/**
 * @file
 * ðŸ”Ÿâ“‚ï¸ w/ ðŸŽ©.
 */

/**
 * Does the thing with the stuff.
 *
 * @param int $objects
 *   How many things we wanna do stuff with.
 * @param array $cm_set
 *   An array containing a 'type' of 'exclude' or 'restrict', as well as a
 *   'pids' array of content model PIDs to perform the 'type' operation on.
 * @param array $collection_set
 *   An array containing a 'type' of 'exclude' or 'restrict', as well as a
 *   'pids' array of collection PIDs to perform the 'type' operation on.
 * @param string $namespace
 *   The namespace to assign to ingested objects.
 *
 * @return array
 *   The batch array thingy.
 */
function ten_million_with_a_hat_ingest_batch($objects, $cm_set, $collection_set, $namespace) {
  global $user;
  return array(
    'title' => t('Ten Million With A Hat Batch Ingest'),
    'init_message' => ("Preparing to ingest $objects objects ..."),
    'progress_message' => t('Time elapsed: @elapsed <br/>Estimated time remaining @estimate.'),
    'error_message' => t('An error has occured.'),
    'file' => drupal_get_path('module', 'ten_million_with_a_hat') . '/ten_million_with_a_hat.module',
    'operations' => array(
      array(
        'ten_million_with_a_hat_ingest_batch_operation',
        array($objects, $user, $cm_set, $collection_set, $namespace),
      ),
    ),
  );
}

/**
 * Processes the thing with the stuff.
 *
 * @param int $objects
 *   The number of objects we're creating.
 * @param object $user
 *   The logged in user.
 * @param array $cm_set
 *   The content model set array defined by ten_million_with_a_hat_ingest_batch.
 * @param array $collection_set
 *   The collection set array defined by ten_million_with_a_hat_ingest_batch.
 * @param string $namespace
 *   The namespace to assign to ingested objects.
 * @param array $context
 *   The batch context.
 */
function ten_million_with_a_hat_ingest_batch_operation($objects, $user, $cm_set, $collection_set, $namespace, &$context) {
  $sandbox = &$context['sandbox'];
  if (empty($sandbox)) {
    $context['finished'] = 0;
    $sandbox['start_time'] = microtime(TRUE);
    $sandbox['completed'] = 0;
    $sandbox['total'] = $objects;
    $sandbox['collections'] = ten_million_with_a_hat_get_collection_pid_array($cm_set, $collection_set);
    $sandbox['other_stuff'] = module_invoke_all('ten_million_with_a_hat_also_do_these_things');
    // Sort and categorize the other stuff.
    uasort($sandbox['other_stuff'], 'drupal_sort_weight');
    $sorted = array();
    foreach ($sandbox['other_stuff'] as $thing) {
      $sorted[$thing['when']][] = $thing;
    }
    $sandbox['other_stuff'] = $sorted;
    // Run before_batch callbacks and messages.
    if (isset($sandbox['other_stuff']['before_batch'])) {
      foreach ($sandbox['other_stuff']['before_batch'] as $thing) {
        $parsed_message = ten_million_with_a_hat_do_thing($thing);
        if (!is_null($parsed_message)) {
          foreach ($parsed_message as $message) {
            $context['message'] = $message;
          }
        }
      }
    }
  }
  if (!empty($sandbox['collections'])) {
    $execution_time_start = microtime(TRUE);
    $collection = islandora_object_load(ten_million_with_a_hat_get_random_array_member(array_keys($sandbox['collections'])));
    $model = ten_million_with_a_hat_get_random_array_member($sandbox['collections'][$collection->id]);
    // Let's make an object wheeeee.
    $tuque = islandora_get_tuque_connection();
    $object = $tuque->repository->constructObject($namespace);
    $object->label = DrupalTestCase::randomName();
    $object->owner = $user->name;
    $object->models = (array) $model;
    $tuque->repository->ingestObject($object);
    $object->relationships->add(FEDORA_RELS_EXT_URI, 'isMemberOfCollection', $collection->id);

    // Between ingest callbacks and results.
    $completed = $sandbox['completed'] + 1;
    if (isset($sandbox['other_stuff']['between_ingests'])) {
      foreach ($sandbox['other_stuff']['between_ingests'] as $thing) {
        $parsed_message = ten_million_with_a_hat_do_thing($thing, $object);
        if (!is_null($parsed_message)) {
          foreach ($parsed_message as $message) {
            $context['message'] = $message;
          }
        }
      }
    }
    $execution_time = ten_million_with_a_hat_get_completion_time($execution_time_start);
    $context['message'] = "$completed/{$sandbox['total']}: Ingested {$object->id} into {$collection->id} with model $model in $execution_time.";

    // Update the completed counter and see if we gotta do stuff.
    $sandbox['completed']++;
    // See if we're finished, and if we are, print all the finished messages.
    $context['finished'] = $sandbox['completed'] / $sandbox['total'];
    if ($context['finished'] === 1) {
      if (isset($sandbox['other_stuff']['after_batch'])) {
        foreach ($sandbox['other_stuff']['after_batch'] as $thing) {
          $parsed_message = ten_million_with_a_hat_do_thing($thing);
          if (!is_null($parsed_message)) {
            foreach ($parsed_message as $message) {
              $context['message'] = $message;
            }
          }
        }
      }
      $completed_time = ten_million_with_a_hat_get_completion_time($sandbox['start_time']);
      $context['message'] = "Ingested {$sandbox['total']} objects into the repository in $completed_time.";
    }
  }

  // Handle the case where your repository is so messed up that there are no
  // valid collections, or where $restrict manages to restrict everything.
  else {
    $sets_were_unconfigured = !empty($collection_set['pids'] || ($cm_set['pids'] = array('islandora:collectionCModel') && $cm_set['type'] == 'exclude');
    $empty_repository_message = "For some reason, no valid collections with policies were found in your repository, so we can't really do anything.";
    $empty_pid_set_message = "No valid collections were found using the restricted content model(s).";
    $context['message'] = $sets_were_unconfigured ? $empty_repository_message : $empty_pid_set_message;
    $context['finished'] = 1;
  }
}

/**
 * Gets the time between a start time and the time of this method's return.
 *
 * @param float $start_time
 *   The start time of execution.
 *
 * @return string
 *   A string representing the execution time.
 */
function ten_million_with_a_hat_get_completion_time($start_time) {
  $total_time = microtime(TRUE) - $start_time;
  // Math time! Populate an array with HH:MM:SS.SSS so we can filter out any
  // parts that result in 0 and just print out valid ones.
  $time = array();
  $time['hour(s)'] = (int) ($total_time / 60 / 60);
  $time['minute(s)'] = (int) ($total_time / 60) - ($time['hour(s)'] * 60);
  $time['second(s)'] = round($total_time - ($time['hour(s)'] * 60 * 60) - ($time['minute(s)'] * 60), 3);
  $time = array_filter($time);
  $return_string = "";
  foreach ($time as $type => $value) {
    $return_string .= "$value $type, ";
  }
  return substr($return_string, 0, -2);
}

/**
 * Raaaaaaandom! This description ends in a full stop, so THERE, coder-review.
 *
 * @param array $array
 *   An array wheeeee.
 *
 * @return string
 *   A random member of the array.
 */
function ten_million_with_a_hat_get_random_array_member($array) {
  return $array[mt_rand(0, count($array) - 1)];
}

/**
 * Returns the list of existing collections as PIDs.
 *
 * @param array $cm_set
 *   The content model set array defined by ten_million_with_a_hat_ingest_batch.
 * @param array $collection_set
 *   The collection set array defined by ten_million_with_a_hat_ingest_batch.
 *
 * @return array
 *   The PID array.
 */
function ten_million_with_a_hat_get_collection_pid_array($cm_set, $collection_set) {
  // Hooookay. First, let's get a collection PID array.
  $collections = array_values(array_map(function($collection) {
    return $collection['pid'];
  }, islandora_basic_collection_get_collections()));
  $pids = array();

  // Now, let's filter the collection list.
  $array_fns = array(
    'restrict' => 'array_intersect',
    'exclude' => 'array_diff',
  );
  $array_fn = $array_fns[$collection_set['type']];
  $collections = $array_fn($collections, $collection_set['pids']);

  // Alright, now to filter the content models.
  foreach ($collections as $collection) {
    $pids[$collection] = array();
    $loaded_collection = islandora_object_load($collection);
    if (!isset($loaded_collection['COLLECTION_POLICY'])) {
      unset($pids[$collection]);
    }
    else {
      $models = ten_million_with_a_hat_get_content_models(islandora_object_load($collection));
      if ($models) {
        $pids[$collection] = $models;

        // Figure out restriction or exclusion of content models.
        $pids[$collection] = array_values($array_fn($pids[$collection], $cm_set['pids']));

        // If that process leaves the PID set empty, dump that collection.
        if (empty($pids[$collection])) {
          unset($pids[$collection]);
        }
      }
      else {
        unset($pids[$collection]);
      }
    }
  }
  return $pids;
}

/**
 * Gets the content models from the collection policy.
 *
 * @param AbstractObject $collection
 *   The collection to get the policy from.
 *
 * @return string|bool
 *   A random content model PID, or FALSE on failure.
 */
function ten_million_with_a_hat_get_content_models(AbstractObject $collection) {
  // It should be guaranteed to have a collection policy by the time we get to
  // this point, but you just never know what some people are gonna do.
  try {
    $policy = new CollectionPolicy($collection['COLLECTION_POLICY']->content);
  }
  catch (Exception $e) {
    return FALSE;
  }
  return array_keys($policy->getContentModels());
}

/**
 * Does a thing and maybe returns a message.
 *
 * @param array $callback
 *   The callback array returned by the also_do_these_things hook.
 * @param AbstractObject|null $object
 *   The object currently being worked with. If it's needed, pass it in, and it
 *   will be set as the first parameter when the callback is run; otherwise,
 *   just leave it as NULL.
 *
 * @return string|null
 *   The parsed message to display, or NULL if nothing will be displayed.
 */
function ten_million_with_a_hat_do_thing($callback, $object = NULL) {
  // Load an include if we must.
  if (isset($callback['file'])) {
    module_load_include($callback['file']['type'], $callback['file']['module'], $callback['file']['path']);
  }

  // Set up the args array. If $object was passed in, add it.
  $args = array();
  if (is_object($object) && is_subclass_of($object, 'AbstractObject')) {
    $args[] = $object;
  }
  if (isset($callback['args'])) {
    $args = array_merge($args, $callback['args']);
  }

  // Do the thing if there is one, and get the response.
  $callback_response = NULL;
  if (isset($callback['callback'])) {
    $callback_response = call_user_func_array($callback['callback'], $args);
  }

  // If there's a message, that gets priority as the response. Otherwise, work
  // with whatever came from the callback, even if it's NULL. Either way, we
  // cast it to an array so we can accept one or more.
  if (isset($callback['message'])) {
    return (array) $callback['message'];
  }
  return (array) $callback_response;
}
